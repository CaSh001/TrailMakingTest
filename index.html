<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Trail Making Test</title>
    </head>
    <body>
<div id="game">
<script src="js/phaser.min.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript">

class Stroop extends Phaser.Scene
{
    constructor ()
    {
        super();
        this.textStyle= { font: "22px Arial", fill: "#000000", align:"center" };
        this.textStyleRed= { font: "22px Arial", fill: "#FF0000", align:"center" };
        this.textStyleBlue= { font: "22px Arial", fill: " #0000FF", align:"center" };
        this.textStyleYellow= { font: "22px Arial", fill: "#FFa500", align:"center" };
        this.textStyleGreen= { font: "22px Arial", fill: "#008000", align:"center" };
        this.textStyleFail= { font: "100px Arial", fill: "#000000", align:"center" };

        this.circles = [];
        this.texts = [];
        this.lines = [];
        
        this.radius = 30;
        this.thickness = 1;
        this.minDistance = 100;
        this.circleCount = 13

        this.timelimit = 300 //"If the test taker fails to complete the test within 5 minutes, the test is discontinued"
        this.level = 0;
        this.isGameOver = false;
        this.progress1 = 0;
        this.progress2 = 0;

        this.progress = 0;

        this.rows = 10
        this.columns = 5
        

        this.finishButton = undefined;
        this.colorButtons = [];
        this.titleText = undefined;
        
        this.overallTime = new Date() //the start time of the current subset
        this.startTime1 = new Date(); //start time of first subset and so on
        this.startTime2 = undefined;
        this.startTime3 = undefined;
        this.endTime3 = undefined; //time when last subset ended
    }


    preload() {
        //  this.load.crossOrigin = "anonymous";
    //   this.load.image("button","assets/Button.jpg")
        this.width, this.height = this.sys.game.canvas;
        this.scale.pageAlignHorizontally = true;
        this.scale.pageAlignVertically = true;
    }

    

    checkGameOver(elapsed){
        if(elapsed >= this.timelimit && !this.isGameOver && this.level < 3){
            this.isGameOver = true;
            this.clearMap()
            var text = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY-this.cameras.main.height/3, "Out of time.", this.textStyleFail)
            .setOrigin(0.5, 0.5);
            this.displayStatistics()
        }
    
    }
    
    randomRange(min, max) { // min最小值，max最大值
        return Math.floor(Math.random() * (max - min)) + min;
    }

    advanceSubset(){
        this.level += 1;
        this.clearMap()

        if(this.level == 1){
            this.startTime2 = new Date()
            this.progress = 0
            this.titleText.setText("Stroop test - Subset B")
            this.populateMap() //some special parameter here
        }
        else{
            this.endTime3 = new Date()
            this.victory()
        }

    }

    victory(){
            this.clearMap()
            this.displayStatistics();
            this.isGameOver = true;

            var text = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY-this.cameras.main.height/3, "Test finished.", this.textStyleFail)
            .setOrigin(0.5)
    }

    pointDistance(x1,y1,x2,y2){
        var a = x1 - x2;
        var b = y1 - y2;

        return Math.sqrt( a*a + b*b );
    }

    goodPosCheck(x,y){
        let good = true
        for (let i = 0; i < this.circles.length; i++){
            if(this.pointDistance(this.circles[i].x,this.circles[i].y,x,y) < this.minDistance){
                good = false
            }
        }
        return !!(good && x && y);
    }

    clickCircle(number){
        if(this.progress + 1 == number){ //Check if correct circle was selected
            if(number > 0){ //Don't draw a line if this is the first ever correct circle selection
                this.lines.push(this.add.line(0,0,this.circles[this.progress].x, this.circles[this.progress].y, this.circles[number].x, this.circles[number].y,100,100 ).setLineWidth(1).setOrigin(0));
            }
            this.progress++
        }
        if(this.progress >= this.circles.length -1){
                console.log("May now progress to Part B")
                this.advanceSubset()
        }
        console.log(this.progress)
    }

    clearMap(){
        for(let i = 0; i < this.circles.length; i++){
            this.circles[i].destroy()
            this.texts[i].destroy()
            if(i < this.lines.length){this.lines[i].destroy()}
        }
    }

    populateMap(){
        for(let counter = 0; counter < this.circleCount; counter++){
            let x;
            let y;

            while(!this.goodPosCheck(x,y)){ //there's usually only 13 circles, so this approach should be fine
                x = this.randomRange(this.radius+this.thickness,this.cameras.main.width-this.radius-this.thickness) //Leave some space on the side. More space needed if the circles are bigger.
                y = this.randomRange(70,this.cameras.main.height-this.radius-this.thickness)
            }
            
            let circle = this.add.circle(x,y,this.radius).setOrigin(0.5,0.5).setStrokeStyle(this.thickness, 'black')
                .setInteractive({ useHandCursor: true })
                .on('pointerdown', () => this.clickCircle(counter))
            let text = this.add.text(0,0, counter+1, this.textStyle).setOrigin(0.5,0.5);

            this.circles[counter] = circle;
            this.texts[counter] = text;
            Phaser.Display.Align.In.Center( text, circle ); //put the text into the center of the circle
        }
    }
        
    create() {
        this.overallTime = new Date() //I made the timers start at creation which is pretty precise. We could also put it at first render if we want even more precision
        this.startTime1 = new Date();

        this.titleText = this.add.text(this.cameras.main.centerX,10, 'Trail making test - Part A', this.textStyle).setOrigin(0.5,0);

        this.populateMap()
    }

    update() {
        if(!this.isGameOver){
            let now = new Date();

            let elapsedTime = (now - this.overallTime);
            //currentTime = Math.floor(currentTime/10) + scope.taroltIdo; 
            let elapsedSeconds = Math.floor(elapsedTime/1000%60) //convert to sec
            this.checkGameOver(elapsedSeconds)
        }
    }

    render() {
    }

    displayStatistics() {
        let textStyleStatistics = { font: "22px Arial", fill: "#000000", align:"center"};

        this.add.text(this.cameras.main.centerX-200,this.cameras.main.centerY-30, 'Subset 1:', textStyleStatistics).setOrigin(0.5,0);
        this.add.text(this.cameras.main.centerX-200,this.cameras.main.centerY+30, 'Subset 2:', textStyleStatistics).setOrigin(0.5,0);
        this.add.text(this.cameras.main.centerX-200,this.cameras.main.centerY+90, 'Subset 3:', textStyleStatistics).setOrigin(0.5,0);
        
        this.add.text(this.cameras.main.centerX-200,this.cameras.main.centerY-90, '', textStyleStatistics).setOrigin(0.5,0);
        this.add.text(this.cameras.main.centerX,this.cameras.main.centerY-90, 'Completion time', textStyleStatistics).setOrigin(0.5,0);
        this.add.text(this.cameras.main.centerX+200,this.cameras.main.centerY-90, 'Correct responses', textStyleStatistics).setOrigin(0.5,0);
        
        let row1time = this.add.text(this.cameras.main.centerX,this.cameras.main.centerY-30, '', textStyleStatistics).setOrigin(0.5,0);
        let row2time = this.add.text(this.cameras.main.centerX,this.cameras.main.centerY+30, '', textStyleStatistics).setOrigin(0.5,0);
        let row3time = this.add.text(this.cameras.main.centerX,this.cameras.main.centerY+90, '', textStyleStatistics).setOrigin(0.5,0);

        //let row1points = this.add.text(this.cameras.main.centerX+200,this.cameras.main.centerY-30, 'b', textStyleStatistics).setOrigin(0.5,0);
        let row2points = this.add.text(this.cameras.main.centerX+200,this.cameras.main.centerY+30, '', textStyleStatistics).setOrigin(0.5,0);
        let row3points = this.add.text(this.cameras.main.centerX+200,this.cameras.main.centerY+90, '', textStyleStatistics).setOrigin(0.5,0);

        if(this.level == 0){
            row1time.setText("Out of time. Test inavlid.")
            
        }else{
            if(this.level > 0){
                let subset1CompletionTime = this.msecToDigital(this.startTime2 - this.startTime1)

                row1time.setText(subset1CompletionTime)

                if(this.startTime3){
                    let subset2CompletionTime = this.msecToDigital(this.startTime3 - this.startTime2)
                    row2time.setText(subset2CompletionTime)
                }else{
                    row2time.setText("Out of time")
                }
                row2points.setText(this.progress1)
            }
            if(this.level > 1){
                if(this.endTime3){
                    let subset3CompletionTime = this.msecToDigital(this.endTime3 - this.startTime3)
                    row3time.setText(subset3CompletionTime)
                }else{
                    row3time.setText("Out of time")
                }
                row3points.setText(this.progress2)
            }
        }
    }

    msecToDigital(msec){
        let sc = Math.floor(msec/1000%60).toLocaleString('en-US', {
            minimumIntegerDigits: 1,
            useGrouping: false
        });
        let msc = (msec % 1000).toLocaleString('en-US', {
            minimumIntegerDigits: 2,
            useGrouping: false
        });
        return sc + "." + msc + " seconds";
    }
    
}
config = {
    type: Phaser.AUTO,
    width: 1024,
    height: 768,
    backgroundColor: '#ffffff',
    scene: [ Stroop ]
    };
const game = new Phaser.Game(config);
</script>
           
    </body>
</html>